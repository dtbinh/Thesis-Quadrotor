\chapter{Experiments and Results}\label{ch:results}
%ADD intro: in this section etc
In Section \ref{sec:set.setup} the experimental setup is explained. The chosen model- and controller parameters are presented.

The experiments that are used are explained and discussed in Section \ref{sec:set.exp}, of which the results are presented and discussed in Section \ref{sec:set.exp}.

A conclusion is made based on the obtained results in Section \ref{set:set.res}.

\section{Setup}\label{sec:set.setup}
\paragraph{Model parameters}
%ADD chosen model parameters 
The simulations are developed using Matlab and Simulink, using the following system parameters.
\begin{equation}\label{key}
\begin{aligned}
J&=\\
m_Q&=\\
\nonumber
\end{aligned}
\quad
\begin{aligned}
d&=\\
c_{\tau f}&=\\
\nonumber
\end{aligned}
\quad
\begin{aligned}
m_L&=\\
l_L&=\\
\nonumber
\end{aligned}
\end{equation}

\paragraph{LQR Control}
\a{lqr} control is based on small angle assumption. Therefore, a traditional modeling method may represent the rotation matrix with a local coordinate system, for example with a Euler Angle parameterization. An \a{lqr} control design is based on a linearized model of the system. The control design is shown in Figure \ref{fig:set.lqr} and the derivation of the model can be found in Section \ref{app:lqr}.
\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=.45\textwidth]{./StyleStuff/dcsc.png}}
	\caption{LQR control design\label{fig:set.lqr}}
\end{figure}		

%ADD chosen parameters LQR
The tuning parameters of the \a{lqr} controller a chosen as follows
\begin{equation}\label{key}
A=\begin{bmatrix}
content...
\end{bmatrix}
\end{equation}
\begin{equation}\label{key}
B=\begin{bmatrix}
content...
\end{bmatrix}
\end{equation}
\begin{equation}\label{key}
C=\begin{bmatrix}
content...
\end{bmatrix}
\end{equation}

where the state $ \mathbf{x} $ and input $ u $ are defined as 
\begin{align}\label{eq:state}
\textbf{x}&=\begin{bmatrix}
\textbf{q}\\
\mathbf{\dot{q}}
\end{bmatrix}\\
\mathbf{q}&=\begin{bmatrix}
x&y&z&\phi&\theta&\psi&\theta_L&\psi_L
\end{bmatrix}^T\\
\mathbf{\dot{q}}&=\begin{bmatrix}
\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\theta}_L&\dot{\psi}_L
\end{bmatrix}^T\\
u&=\begin{bmatrix}
f&M_\phi&M_\theta&M_\psi
\end{bmatrix}^T
\end{align}

\paragraph{Geometric Control}
%ADD chosen parameters GC
The controller gains in Equations \ref{eq:con.M},\ref{eq:con.R},\ref{eq:con.q} are chosen to be
\begin{equation}\label{key}
\begin{aligned}
k_R&=\\
k_\Omega&=\\
\end{aligned}
\quad
\begin{aligned}
k_q&=\\
k_\omega&=\\
\end{aligned}
\quad
\begin{aligned}
k_x&=\\
k_v&=
\nonumber
\end{aligned}
\end{equation}


\subsection{Command Filtering}
%ADD Why is Command Filtering needed? 
Implementation of the backstepping approach also increases the order of the states. Thus, a consequence of backstepping control is that inner control loops become a function of the commanded signals and their higher derivatives, generated by an outer loop.
Instead of analytic differentiation of these terms, which can be tedious and require high computational costs, these values can be obtained with the use of a Command Filter, which is explained in more detail in \cite{Farrell2008}.

Basically, the command signal is pre-filtered by a low pass filter 

with the following state space representation
%CHECK waar dit ook alweer vandaan kwam. Reference in Djapic/Farell -> 3e order voor bacterieen ofzo
\begin{align}\label{key}
\dot{x}_1 &= x_2\\ %dxc
\dot{x}_2 &= x_3\\ %ddxc
\dot{x}_3 &= -(2\zeta \omega_{n2}+\omega_{n1})x_3-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_2-(\omega_{n1}\omega_{n2}^2)(x_1-x_c^o)
\end{align}
where $ x_1 = x_c$, $ x_2 = \dot{x}_c$ and $ x_3 = \ddot{x}_c$. 

The transfer function of the original commanded input signal $ X_c^o $ and the filtered output $ X_c $ has the form
\begin{equation}\label{key}
\frac{X_c(s)}{X_c^o(s)}=H(s)=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}
\end{equation}
Where $ \zeta $ is the damping ratio and $ \omega_n $ the undamped natural frequency. See Figure \ref{fig:set.CF} and \ref{fig:app.CF}.

This command filter is implemented to compute $ \dot{R}_c, \ddot{R}_c,\dot{q}_c, \ddot{q}_c $.
%\begin{equation}\label{key}
%
%\end{equation}

%CHECK
%Examples from \cite{Farrell2008} and \cite{Djapic2008}. 

***************************************\\
%ADD Pro Con Command filter
Easy implementation. Less computational effort.

Less accurate, because filters high frequency signals.

***************************************\\

The load attitude controller generates a commanded QR attitude $ R_c $ and its derivative $ \dot{R}_c $. In the same fashion, the load position controller generates a commanded load attitude $ q_c $ and its derivative $ \dot{q}_c $. 

The controllers are functions of these commanded signals and their derivatives. Instead of analytic differentiation of these signals, they are obtained by integration by applying a third order low pass filter to the original signals $ R_c^o $ and $ q_c^o $. 
The state space implementation of this third order filter is \cite{Djapic2008}


\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=.45\textwidth]{./StyleStuff/dcsc.png}}
	\caption{Representation of the command filter\label{fig:set.CF}}
\end{figure}		

\begin{align}\label{eq:CF}
\frac{x_c}{x_c^o}&=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}\\
\Rightarrow x_c^{'''}&=-(2\zeta\omega_{n2}+\omega_{n1})x_c^{''}-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_c^{'}-(\omega_{n1}\omega_{n2} ^2)(x_c-x_c^o)
\end{align}

\section{Experiments}\label{sec:set.exp}

\a{lqr} is an optimal control strategy and will be used to compare its result to a Nonlinear Geometric Controller.

$ x_d(t) $ is required to be smooth for the Geometric Control. Trajectories are generated by hand, however it is possible to compute these with trajectory generating algorithms too.

\subsection{Performance Criteria}
Performance  that can be evaluated for different cases can be specified by the following
\begin{outline}
	\1 Step Response
	\2 Settling time (if swing minimization is important)
	\2 Rising time (important if time critical)
	\2 Overshoot (if max swing is critical)
	\2 Steady state error / swing of load (if accuracy is important)
	\2 Max load angle
	
	\1 Disturbance Rejection
	
	\1 Trajectory tracking
	\2 Can we minimize time, while minimizing position error (All Cases)
	\2 Minimum position error (All Cases)
	\2 Maximum amplitude/frequency of wave with respect to stability (Case B)
	
	\1 Computational Effort (?)
\end{outline}

%ADD 
%Explain cases, why interesting and what can be expected?\\

\subsection{Case A}
%ADD 
%Explain cases, why interesting and what can be expected?\\
In this case a trajectory is generated in order to transport the load from the starting position along one direction in order to reach the final position, while maintaining the same hight. 
From point A to point B
The fast

%ADD xdes
%ADD inputs f M
%ADD QR attitude
%ADD 

\subsection{Case B}
%ADD 
%Explain cases, why interesting and what can be expected?\\


\subsection{Case C}
%ADD 
%Explain cases, why interesting and what can be expected?\\
In this case a trajectory is generated to test multiple disciplines. 
The trajectory has the shape of a sine wave that varies in amplitude in the direction of the x-axis, while moving along the y-axis and going up and down in height.
Different velocities are required to track the trajectory. While tracking the right \a{qr} attitude to reach these velocities, it can be expected to be harder for the controller to also maintain the desired height. 

%CHECK nog nodig?
%\begin{figure}[h!]
%	\centering
%	\makebox[\textwidth][c]{\includegraphics[width=.2\paperwidth]{./StyleStuff/dcsc.png}}
%	\caption{Cases of which the performance could be evaluated \label{fig:routes}}
%\end{figure}

\section{Results}\label{set:set.res}
\subsection{Case A}


\subsection{Case B}


\subsection{Case C}


\section{Conclusion}\label{set:set.con}
%CHECK 
%What can we learn and conclude from different performance comparisons

%What is its value of nonlinear control compared to linear control

%No restrictions on rotor direction. is it possible to turn 2 ways?

%Could it be interesting for a real-time on-board controller
%Considering the computational power of an on-board processor is limited
%computational effort vs what?
