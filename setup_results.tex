\chapter{Experiments and Results}\label{ch:results}
%ADD intro: in this section etc
In Section \ref{sec:set.setup} the experimental setup is explained. The chosen model- and controller parameters are presented.

The experiments that are used are explained and discussed in Section \ref{sec:set.exp}, of which the results are presented and discussed in Section \ref{sec:set.exp}.

A conclusion is made based on the obtained results in Section \ref{set:set.res}.

\section{Setup}\label{sec:set.setup}
\paragraph{Model parameters}
%ADD chosen model parameters 
The simulations are developed using Matlab and Simulink, using the system parameters found in Table \ref{tab:set.par}.

\begin{table}[h!]
	\centering
	\begin{tabular}{|l|ll|l|}
		\hline
		\textbf{Parameter}&\textbf{Value}&&\textbf{Description}\\
		\hline
		$ m_Q $&4.34& $ kg $&Quadrotor Mass\\
		$ m_L $&0.1 &$ kg $&Load Mass\\
		$ l $&0.315& $ m $&Arm length from \a{qr} \a{com} to rotor\\
		$ L $&0.7 &$ m $& Cable Length\\
		$ I_{xx} $&0.0820&$kgm^2 $&Quadrotor Inertia about x-axis\\
		$ I_{yy} $&0.0845&$kgm^2 $&Quadrotor Inertia about y-axis\\
		$ I_{zz} $&0.1377&$kgm^2 $&Quadrotor Inertia about z-axis\\
		$ d $&&&Drag Constant\\
		$ b $&&&Thrust Constant\\
		$ c_{\tau_f} $&&& Constant	\\
		\hline	
	\end{tabular}
	\caption{Modeling Parameters}
	\label{tab:set.par}
\end{table}

\paragraph{LQR Control}
%ADD why LQR, what is good for / known for
% tuning / easy tuning / 
A \acf{lqr} controller is used to compare the performance of the nonlinear geometric controller. 
\a{lqr} control uses an algorithm to obtain a state-feedback controller, minimizing a cost function depending on the states and weight factors. 
%is widely used and known for its robustness, because small modeling errors still allow the optimization to be executed.
An \a{lqr} design is shown in Figure \ref{fig:set.lqr}
\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=.45\textwidth]{./StyleStuff/dcsc.png}}
	\caption{LQR control design\label{fig:set.lqr}}
\end{figure}

\a{lqr} control is based on a small angle assumption. Therefore, a traditional modeling method may represent the rotation matrix with a local coordinate system, for example with an Euler Angle parameterization. 
A continuous time linearized model of the system used in this controller is represented in the following form 
\begin{align}\label{eq:ss}
\mathbf{\dot{x} }&=A\mathbf{x}+Bu\\
y&=C\mathbf{x}+Du
\end{align}
where $ \mathbf{x} $ is the state vector and $ u $ is the input vector, defined as follows
\begin{align}\label{eq:state}
%	\textbf{x}&=\begin{bmatrix}
%		\textbf{q}\\
%		\mathbf{\dot{q}}
%	\end{bmatrix}\\
%	\mathbf{q}&=\begin{bmatrix}
%		x&y&z&\phi&\theta&\psi&\phi_L&\theta_L
%	\end{bmatrix}^T\\
%	\mathbf{\dot{q}}&=\begin{bmatrix}
%		\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\phi}_L&\dot{\theta}_L
%	\end{bmatrix}^T\\
\mathbf{x}&=\begin{bmatrix}
x&y&z&\phi&\theta&\psi&\phi_L&\theta_L&\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\phi}_L&\dot{\theta}_L
\end{bmatrix}^T\\
	u&=\begin{bmatrix}
		f&M_\phi&M_\theta&M_\psi
	\end{bmatrix}^T
\end{align}
%ADD figure that define phiL and thetaL
where $ \phi_L $ and $ \theta_L $ are the angle of rotation of the load about the x-axis and y-axis in \BF, respectively.
The derivation of $ A, B, C, D $ can be found in Section \ref{app:lqr}. 

Using \texttt{Matlab} command \texttt{lqr(A,B,Q,R)}, an optimal gain matrix $ K $ is calculated, such that the state-feedback law $ u=-K\mathbf{x} $ minimizes the quadratic cost function defined as
\begin{equation}\label{key}
J(u)=\int_{0}^{\infty}(\mathbf{x}^TQ\mathbf{x}+u^TRu)dt
\end{equation}
%where $ Q $ and $ R $ denote weight matrices that penalize the states and inputs in the cost function. 
The weight matrices $ Q $ and $ R $ that define the effects of the states and inputs in the cost function, and the calculated gain matrix $K $ can be found in Section \ref{app:lqr}. 

%CHECK dubbelop?
%where the state $ \mathbf{x} $ and input $ u $ are defined as 
%\begin{align}\label{eq:state}
%\textbf{x}&=\begin{bmatrix}
%\textbf{q}\\
%\mathbf{\dot{q}}
%\end{bmatrix}\\
%\mathbf{q}&=\begin{bmatrix}
%x&y&z&\phi&\theta&\psi&\theta_L&\psi_L
%\end{bmatrix}^T\\
%\mathbf{\dot{q}}&=\begin{bmatrix}
%\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\theta}_L&\dot{\psi}_L
%\end{bmatrix}^T\\
%u&=\begin{bmatrix}
%f&M_\phi&M_\theta&M_\psi
%\end{bmatrix}^T
%\end{align}

\paragraph{Geometric Control}
%ADD chosen parameters GC
The chosen controller gains in Equations \ref{eq:con.M},\ref{eq:con.R},\ref{eq:con.q} can be found in Table \ref{tab:set.gains}.

\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Gain}&\textbf{Value}\\
		\hline
		$ k_R $&\\
		$ k_\Omega $&\\
		$ k_q $&\\
		$ k_\omega $&\\
		$ k_x $&\\
		$ k_v $&\\	
		\hline
	\end{tabular}
	\caption{Controller Gains}
	\label{tab:set.gains}
\end{table}

\subsection{Command Filtering}
%ADD Why is Command Filtering needed? 
%ADD Pro Con Command filter
%Easy implementation. Less computational effort.
%Less accurate, because filters high frequency signals.
%CHECK
%Examples from \cite{Farrell2008} and \cite{Djapic2008}. 
A consequence of a backstepping control approach, is that it also increases the order of the states. The inner control loops become a function of the commanded signals and their higher derivatives, which are generated by an outer loop.
In the earlier presented control design, the load attitude controller generates a commanded QR attitude $ R_c $ and its derivative $ \dot{R}_c $. In the same fashion, the load position controller generates a commanded load attitude $ q_c $ and its derivative $ \dot{q}_c $. 
Instead of analytic differentiation of these terms, which can be tedious and require high computational costs, these values can be obtained with the use of a Command Filter, which is explained in more detail in \cite{Farrell2008}. 

The basic idea is that the command signal is pre-filtered by a low pass filter and generates an estimation of the derivatives of the commanded signal. 
In this thesis a backstepping command filter of third order is applied to compute $ \dot{R}_c, \ddot{R}_c,\dot{q}_c, \ddot{q}_c $. 
The transfer function of the original commanded input signal $ X_c^o $ and the filtered output $ X_c $ has the form
\begin{equation}\label{key}
\frac{X_c(s)}{X_c^o(s)}=H(s)=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}
\end{equation}
Where $ \zeta $ is the damping ratio and $ \omega_n $ the undamped natural frequency. See Figure \ref{fig:set.CF} and \ref{fig:app.CF}.
The filter has the following state space representation
%CHECK waar dit ook alweer vandaan kwam. Reference in Djapic/Farell -> 3e order voor bacterieen ofzo
\begin{align}\label{key}
\dot{x}_1 &= x_2\\ %dxc
\dot{x}_2 &= x_3\\ %ddxc
\dot{x}_3 &= -(2\zeta \omega_{n2}+\omega_{n1})x_3-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_2-(\omega_{n1}\omega_{n2}^2)(x_1-x_c^o)
\end{align}
where $ x_1 = x_c$, $ x_2 = \dot{x}_c$ and $ x_3 = \ddot{x}_c$. 
\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=.45\textwidth]{./StyleStuff/dcsc.png}}
	\caption{Representation of the command filter\label{fig:set.CF}}
\end{figure}		

%The controllers are functions of these commanded signals and their derivatives. Instead of analytic differentiation of these signals, they are obtained by integration by applying a third order low pass filter to the original signals $ R_c^o $ and $ q_c^o $. 
%The state space implementation of this third order filter is \cite{Djapic2008}
%\begin{align}\label{eq:CF}
%\frac{x_c}{x_c^o}&=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}\\
%\Rightarrow x_c^{'''}&=-(2\zeta\omega_{n2}+\omega_{n1})x_c^{''}-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_c^{'}-(\omega_{n1}\omega_{n2} ^2)(x_c-x_c^o)
%\end{align}

\section{Experiments}\label{sec:set.exp}
Performance of both \a{lqr} control and a Nonlinear Geometric Control is evaluated by comparing their ability to track a load trajectory with minimal error. 
The desired load trajectory $ x_{L,d}(t) $ is required to be smooth for Geometric Control, such that feed forward terms can be generated and implemented. 
In this thesis the desired load paths are generated by hand, and the required velocity and acceleration is calculated by a command filter. 
%\a{lqr} is a linear optimal control strategy and will be used to compare its result to a Nonlinear Geometric Controller.

In a step function the system is subjected to a sudden input. The stability of the system can be investigated by observing whether it is able to reach a stationary final state, and how fast this can be reached. 

What observations can be made in order to adapt the controller properties that improve performance of the test cases.

%\paragraph{Performance}

%\begin{outline}
%	\1 Step Response
%	\2 Settling time (if swing minimization is important)
%	\2 Rise time (important if time critical)
%	\2 Overshoot (if max swing is critical)
%	\2 Steady state error / swing of load (if accuracy is important)
%%	\1 Max load angle
%%	\1 Disturbance Rejection
%	\1 Trajectory tracking
%	\2 How do the errors evolve along the trajectory
%	\2 What is the maximum error during the trajectory
%%	\2 Can we minimize time, while minimizing position error (All Cases)
%%	\2 Minimum position error (All Cases)
%%	\2 Maximum amplitude/frequency of wave with respect to stability (Case B)
%%	\1 Computational Effort (?)
%\end{outline}

%\begin{description}\label{key}
%\item[Step response] How does the system respond on a smooth step in load trajectory?
%\item[Settling time] How long does it take to stabilize after 
%\end{description}

%ADD 
%Explain cases, why interesting and what can be expected?\\

\subsection{Case A}
%ADD 
%Explain cases, why interesting and what can be expected?\\
In this case a smooth step-like trajectory is generated to transport the load from the starting position along the direction of the x-asis to the final position. 

It will show if the system is fast enough to track the position.

From point A to point B
The fast

\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdes40}}}}
\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot40}}}}
	\caption{Desired Load Position Case A\label{fig:set.caseA}}
\end{figure}		

%ADD xdes
%ADD inputs f M
%ADD QR attitude
%ADD 

\subsection{Case B}

%ADD 
%Explain cases, why interesting and what can be expected?\\
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdes41}}}}
\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot41}}}}
	\caption{Desired Load Position Case B\label{fig:set.caseB}}
\end{figure}		

\subsection{Case C}
%ADD 
%Explain cases, why interesting and what can be expected?\\
In this case a trajectory is generated to test multiple disciplines. 
The trajectory has the shape of a sine wave that varies in amplitude in the direction of the x-axis, while moving along the y-axis and going up and down in height.
Different velocities are required to track the trajectory. While tracking the right \a{qr} attitude to reach these velocities, it can be expected to be harder for the controller to also maintain the desired height. 

%CHECK nog nodig?
%\begin{figure}[h!]
%	\centering
%	\makebox[\textwidth][c]{\includegraphics[width=.2\paperwidth]{./StyleStuff/dcsc.png}}
%	\caption{Cases of which the performance could be evaluated \label{fig:routes}}
%\end{figure}
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdes41}}}}
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot41}}}}
	\caption{Desired Load Position Case C\label{fig:set.caseC}}
\end{figure}		


\section{Results}\label{set:set.res}
\subsection{Case A}
In Figure \ref{fig:set.caseAres} the results are shown for the Nonlinear Geometric Controller. The desired and actual load trajectory, and the position error are shown in Figure \ref{fig:AxL} and Figure \ref{fig:AexL}, respectively.
From this can be seen that a small steady state error remains in the z-direction. However, $ (e_x,e_v)=(0,0) $ is exponentially attractive. %CHECK kan deze error nog verholpen worden? Gain ex ev omhoog? 
Figure \ref{fig:AeR} and Figure \ref{fig:Aeq} also show that the tracking error for both attitude and angular velocity are exponentially attractive.
Figure \ref{fig:APsiR} confirms Equation \ref{eq:con.PsiRconv} and likewise, Figure \ref{fig:APsiq} confirms Equation \ref{eq:con.Psiqconv} and it can be seen that both the configuration error $ \Psi_R $ on $ SO(3) $ and $ \Psi_q$ on $ \mathbb{S}^2 $ is smaller than 2 and converges to zero along the trajectory.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-xL40}}\label{fig:AxL}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-exL40}}\label{fig:AexL}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eR40}}\label{fig:AeR}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eq40}}\label{fig:Aeq}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-PsiR40}}\label{fig:APsiR}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-Psiq40}}\label{fig:APsiq}}}
	\caption{Results Nonlinear Geometric Control Case A \label{fig:set.caseAres}}
\end{figure}	

\subsection{Case B}
\ref{fig:set.caseBres}
%CHECK right pictures?
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xL41}}\label{fig:}}}	
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-exL41}}\label{fig:}}}	
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eq41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eR41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-PsiR41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-Psiq41}}\label{fig:}}}
	\caption{Results Nonlinear Geometric Control Case B \label{fig:set.caseBres}}
\end{figure}		

\subsection{Case C}
\ref{fig:set.caseCres}
%CHECK right pictures?
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xL41}}\label{fig:}}}	
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-exL41}}\label{fig:}}}	
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eq41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.5\textwidth]{\dir{LPOSQRL-eR41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-PsiR41}}\label{fig:}}}
\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-Psiq41}}\label{fig:}}}
	\caption{Results Nonlinear Geometric Control Case C \label{fig:set.caseCres}}
\end{figure}	

\section{Conclusion}\label{set:set.con}
%CHECK 
%What can we learn and conclude from different performance comparisons

%What is its value of nonlinear control compared to linear control

%No restrictions on rotor direction. is it possible to turn 2 ways?

%Could it be interesting for a real-time on-board controller
%Considering the computational power of an on-board processor is limited
%computational effort vs what?

The nonlinear geometric controller depends on feed forward terms that are obtained from the desired trajectories. These terms are approximated by a command filter, meaning that the accuracy decreases because high frequency terms are filtered.
Trajectory generation approaches exist that are able to generate the required desired position, velocity and acceleration by 
however it is possible to compute these with trajectory generating algorithms too.
