\chapter{Experiment}\label{ch:exp}
The experimental procedure is explained in Section \ref{sec:exp.proc}. 
It is discussed what experiments can be done in order to investigate closed-loop stability and the tracking performance of nonlinear geometric control.
In addition, a comparison is made between the performances of the nonlinear geometric controller and a linear \a{lqr} controller.

The controllers are tested on their ability to track a desired load trajectory. 
Section \ref{sec:exp.traj} presents several desired load trajectories that create different challenges for load position tracking, and it is discussed what could be expected from these experiments.

%***************************************\\
%Bart: Challenge of what? control challenges?\\
%Nam: challenges for load position tracking, beter?
%
%***************************************\\
%in what way a comparison can be made between the performance of the controllers.
%ADD 1 wat brengt mij tot keuze trajectories 
%ADD 2 trajectories
%ADD 3 waar ga ik de resultaten op checken

In Section \ref{sec:exp.setup} the experimental setup is discussed. 
The model parameters for the \a{qr}-load system are presented, as well as the controller parameters for both nonlinear geometric controller and \a{lqr} controller.
The notion of a backstepping command filter is made to explain a mathematical simplification in the experiments.

Finally, in Section \ref{sec:exp.results} the results that are obtained from the load trajectory tracking experiments are presented and discussed.
The stability of the closed-loop system is demonstrated for the nonlinear geometric controller and the differences in linear- and nonlinear controller performance are discussed.

\newpage
\section{Procedure}\label{sec:exp.proc}
The goal of the experiments is to analyze the controller performance and closed-loop stability in a load position tracking task.
The load positions are described by smooth trajectories $ x_{L,d}(t) $ in order to get well-defined control functions.
%, which is required to be smooth for geometric control, such that feed forward terms can be generated and implemented. 
In this work the desired load paths are generated by hand. 
The corresponding required velocity and acceleration are calculated by a \textit{command filter}, which is explained in more detail in Section \ref{sec:exp.setup}.
For the purpose of load transportation, both controllers can be used. The difference is in the definition of the problem.
Stability of the nonlinear geometric controller is evaluated by analyzing the error functions, as described in Chapter \ref{ch:control}.
Performance of both nonlinear geometric control and \a{lqr} control are evaluated by comparing their ability to track a load trajectory with minimal error. 
The differences based on response time, load tracking accuracy and peculiarities are analyzed and discussed.

In linear control, a linearized model is obtained by assuming small angles of both load and \a{qr} around an equilibrium point. 
The model is obtained by assuming an equilibrium point such that the \a{qr} is in a hover position with the load hanging directly underneath it.
The \a{lqr} cost function allows control of the inputs $ f $ and $ M $, and the states which define the \a{qr} position, \a{qr} attitude and load attitude. 
As a result, the linearized model does not allow direct reference tracking of the load position. 
%Therefore, full load position control is not possible. 
%This can be approached by \a{qr} position control and/or minimization of the load swing. 
This limitation illustrates an important difference between the use of a linear and a nonlinear model. 

The \a{lqr} controller in this thesis is designed to track a \a{qr} position and to minimize the load swing. 
The tuning of the \a{lqr} controller involves a trade-off between accurate \a{qr} movements and minimal load swing. 
%The controller will apply reference tracking of t
The \a{qr} position is based on the same desired load trajectories that are used for the nonlinear geometric controller. 
When assuming small angles and minimal load swing, the \a{qr} position should be approximately a cable length above the predefined desired load position. 
Note that this will not allow a direct comparison of the load trajectory tracking performance, nevertheless this will illustrate important differences between the controllers. 
%
%are defined in a different way.
%with different ob
%in means of
%and allow conclusions to be made about the 
%in load attitude
%exposed to trajectories 
%where large angles are required to track fast maneuvers

% Since it is not possible for \a{lqr} to apply reference tracking for the load trajectory, 
%\a{lqr} is a linear optimal control strategy and will be used to compare its result to a nonlinear geometric controller.

\newcommand{\caseA}{71}
\newcommand{\caseB}{72}
\newcommand{\caseC}{74}
\newpage
\section{Trajectories}\label{sec:exp.traj}
%\begin{description}\label{key}
%\item[Step response] How does the system respond on a smooth step in load trajectory?
%\item[Settling time] How long does it take to stabilize after 
%\end{description}

%What observations can be made in order to adapt the controller properties that improve performance of the test cases.
%ADD
%Description of tests that apply on all cases.

This section discusses a number of cases that describe different load trajectories for the \a{qr}-load system.
A description is given of desired trajectory and the challenges that are involved.

\subsection*{Case A}
%ADD 
%Explain cases, what can be expected?\\

%\begin{outline}
%	\1 Step Response
%	\2 Settling time (if swing minimization is important)
%	\2 Rise time (important if time critical)
%	\2 Overshoot (if max swing is critical)
%	\2 Steady state error / swing of load (if accuracy is important)
%%	\1 Max load angle
%%	\1 Disturbance Rejection
%	\1 Trajectory tracking
%	\2 How do the errors evolve along the trajectory
%	\2 What is the maximum error during the trajectory
%%	\2 Can we minimize time, while minimizing position error (All Cases)
%%	\2 Minimum position error (All Cases)
%%	\2 Maximum amplitude/frequency of wave with respect to stability (Case B)
%%	\1 Computational Effort (?)
%\end{outline}

%ADD
%why a step function is interesting

%In this first case 
In the first case, a smooth step-like trajectory is generated to investigate the step response of the system.
The step response is a commonly used analysis tool to obtain information about the stability of a dynamical system.
%In a regular step function the system
A step function is used to investigate the effects of a sudden input to the desired load position.
%, such as overshoot, settling time or steady-state value.
%When the controller tries to track the trajectory
Typical response properties that can be investigated are: rise time, overshoot, settling time and steady-state error.
%of the response 
%respond to be investigated are 
%It can be investigated whether the system responds with overshoot or undershoot, the needed settling time and whether the desired steady-state is reached.
The goal is to transport the load from a starting position to a final position along the y-axis. 

***************************************\\
Bart: Suggestie: Aangezien je een custom step hebt gemaatk verwacht ik hier wat specs: wat is de max snelheid en acc. Geeft meer gevoel waarom je die 15\% overshoot krijgt in je results.
\\
Nam: Figure veranderd. Ik heb het idee dat het niet per se aan de snelheid of acceleratie ligt, maar eerder de mate waarmee de acceleratie verandert. Dat vereist gigantisch snelle rotatie veranderingen. Dat kan het systeem niet aan. Zie Section \ref{sec:exp.results}, case A. Genoeg omschreven/verklaard?

***************************************\\

The geometric control design requires the desired load trajectory to be twice-differentiable. For this reason a smooth step-like function is generated.
The load position controller outputs a commanded load attitude signal $ q_c $, see Equation \ref{eq:con.q}, 
which is a function of $x_{L,d}, \dot{x}_{L,d} $ and $ \ddot{x}_{L,d} $. Figure \ref{fig:set.caseA} shows the desired load position, velocity and acceleration.
It can be expected that the step response is only able to track a trajectory up to a limited steepness. 
The commanded acceleration in Equation \ref{eq:con.A} is required to be bounded, such that 
\begin{equation}\label{eq:set.acc}
\parallel (m_Q+m_L)(\ddot{x}_{L,d}+ge_3)+m_QL(\dot{q}\cdot\dot{q})q \parallel < B
\end{equation}
where $ B $ is a positive constant \cite{Lee2010}. 
%is a design parameter to guarantee Lyapunov stability \cite{Sreenath2013c}. 
This might result in large errors, and it must be investigated whether the system is able to maintain stable. Input constraints are not yet considered in the control design, this might be required to avoid input commands that are out of reach and make the system instable.

***************************************\\
Bart: Bedoel je dat large errors kunnen optreden als eq. 3-1 niet waar is? dus > B. Waar is design parameter B van afhankelijk? Kun je B zelf "tunen" zodat je systeem minder snel instabiel wordt?\\
Nam: Aangenomen dat je Equation \ref{eq:set.acc} bedoelt; nee. B is een positieve constante waarde, niet een tuning parameter. (verbeterd in de tekst) Vergelijkbaar met een voorbeeld over stabiliteit; Een functie is stabiel als er een waarde $ \delta $ bestaat, zodat $ \parallel x(t) -x_{equilibrium} \parallel < \delta$. Het gaat er om dat wanneer  Equation \ref{eq:set.acc} oneindig groot is (not bounded), dat $ A $ in Equation \ref{eq:con.A} oneindig groot wordt, en daardoor klapt $ q_c=\frac{A}{\parallel A\parallel} $ in Equation \ref{eq:con.q}.

***************************************\\
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\label{fig:AxLd}{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-allxLd\caseA}}}}
%	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:AxLdplot}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot\caseA}}}}
	\caption{Desired load Position Case A\label{fig:set.caseA}}
\end{figure}		

%***************************************\\
%Bart: Did you found out with Daniel why a steep step works with simple pid controllers?\\
%Nam: Waarschijnlijk.. $ e_v $ wordt instantaan oneindig.\\
%PID: De gecalculeerde gewenste input wordt instantaan oneindig. De werkelijk response is gelimiteerd door het systeem. Een actuator zal zijn hoogst mogelijke output geven, maar 1 sample periode erna is dat al niet meer nodig, omdat $e_v $ dan weer gezakt is.  \\
%NGC: load position controller berekent een commanded load attitude $ q_c=\frac{A}{\parallel A\parallel} $, waar $ A = -k_xe_x-k_ve_v+(m_Q+m_L)(\ddot{x}_{L,d}+ge_3)+m_QL(\dot{q}\cdot\dot{q})q $. 
%Als $ e_v \rightarrow\infty$, dan krijg je rotzooi. Het lijkt me dat de controller hierdoor niet meer goed gedefinieërd is. \\
%Verderop in een paper staat nog: \textit{Assumed that commanded acceleration is uniformly bounded such that} $\parallel (m_Q+m_L)(\ddot{x}_{L,d}+ge_3)+m_QL(\dot{q}\cdot\dot{q})q\parallel < B $. En dat is niet het geval wanneer er een keiharde step wordt toegepast.
%
%Voorlopige conclusie: \\
%PID: controller berekent één sampletijd een oneindig hoge desired input, actuatoren zullen pieken, maar het systeem klapt niet (per se). \\
%NGC: load position controller kan geen commanded state meer berekenen voor desired input, waarschijnlijk gaan de control laws hierdoor overhoop. \\
%Verder \cite{Bullo2005} geeft een voorbeeld voor trajectory tracking op $ \mathcal{S}^2 $: "Let $ t\mapsto r(t) $ be a twice-differentiable reference trajectory with bounded velocity ...". Wellicht dat met een steile smooth step en een limiet op inputs, dat $ q_c $ (en de rest van de controllers) wel goed gedefinieërd is?
%
%***************************************\\

%***************************************\\
%Bart: Also speed of response/ rise time is important or not? With high rise time it is easy to have no overshoot but mostly this is not desired behavior.\\
%Nam: Edited, please check
%
%***************************************\\

%***************************************\\
%Bart: You mentioned ""What could be expected from these experiments" --> I don't see the expectation for the step response om this paragraph\\
%Nam: Added. Compleet genoeg?
%
%***************************************\\

\subsection*{Case B}

%PLANNING: 
%make case to test limits on \a{qr} angles while tracking load trajectory. Is nonlinear GC useful for such aggressive maneuvers?

% BART:
%Enbje wilt dat hellen onderzoelen omdat dat past bij je onderzoeksvraag: agressief manoeuvre en  nonlin

%To investigate the behavior of the system undergoing aggressive maneuvers
The nonlinear geometric controllers are expected to be able to deal with large angles in the \a{qr} attitude, allowing aggressive maneuvering.
This can be tested by describing the next trajectory as a sine wave, growing in amplitude over time, in the direction of one axis in \IF.
This will result in a increasing distance between the load positions at each end of the movement, requiring increasing velocities on both the \a{qr} and the load.
To achieve this, it can be expected that the \a{qr} requires large rotations. It is investigated whether the system is able to perform load position tracking while dealing with increasing \a{qr} rotations.
%attitude needs large angles 
%to fly in a large angle.
%It can be expected that the \a{qr} attitude angles are large to reach the desired velocities.

The trajectory is generated by the product of signals A and B, shown in Figure \ref{fig:set.sinecaseB}, of which the first signal is a sine and the second consists of a smooth step up and down. This product results in signal C, shown in the same figure, which is chosen to be the trajectory in the direction of the y-axis of \IF. 
Figure \ref{fig:set.caseB} shows the desired load position, velocity and acceleration.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][Trajectory generation\label{fig:set.sinecaseB}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-sineCaseB\caseB}}}}	
	\makebox[.49\textwidth][c]{\subfloat[][Desired trajectory \label{fig:set.xLdcaseB}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-allxLd\caseB}}}}
%	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot\caseB}}}}
	\caption{Desired load Position Case B\label{fig:set.caseB}}
\end{figure}			


***************************************\\
Bart: Misschien geldt dit voor al je cases: wetenschappelijk gezien wil je net wat meer info over je trajectories.  Iemand zou je experiment moeten kunnen nadoen. Ze zouden je trajectories kunnen digitaliseren, maar wat meer info over bijv. maximale snelheden en acceleraties zou denk ik netjes zijn om te geven. Je grafieken geven in iedr geval een helder beeld over positie, maar dus indirect in mindere mate info over vel en acc. Deze zijn ook belangrijk voor agressive manouvres.\\
Nam: all cases desired load position/velocity/acceleration toegevoegd. Duidelijker en voldoende?

***************************************\\

\subsection*{Case C}
%For this case a
%A trajectory is generated 
This case is generated in order to investigate the response on tracking multiple conditions at the same time.  
%such as sideways position tracking with high velocity, without losing height while tracking up and down motion. 
%this case describes the desired trajectory as follows.
The trajectory along the y-axis in \IF is described as a sine wave with an increasing and decreasing amplitude over time, as in case B.
%, which will require changing and high velocities. 
While following this wave, the load is commanded to move forward along the x-axis, while tracking an increasing and decreasing height.
%has the shape of a sine wave that moves along the y-axis and varies in amplitude in the direction of the x-axis, while 
 %going up and down in the direction of the z-axis.
%Changing velocities are required to track 
The changing amplitude of the trajectory that moves from side to side, requires varying velocities to 'keep up' with the trajectory. \\
In this case it can also be expected that large \a{qr} rotations are required to track the changing amplitude of the sine wave and the varying velocities.
While doing so, the \a{qr} is expected to lose height due to the rotations.
It can be investigated how the close-loop system responds to the forward movement, while tracking a swinging motion and whether the controller can correct for the expected height loss, while tracking an up and down movement. 

%movement, while moving forward, up and down.
%How the system reacts on the changes in height
Figure \ref{fig:set.caseC} shows the desired load position and a three dimensional representation, which can be seen as a \textit{figure eight} increasing and decreasing in size.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdes\caseC}}}}
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-xLdesplot\caseC}}}}
	\caption{Desired load Position Case C\label{fig:set.caseC}}
\end{figure}

Figure \ref{fig:set.caseC} shows the desired velocity and accelerations in all directions. 
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-dxLdes\caseC}}}}
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:}]{\includegraphics[width=.45\textwidth]{\dir{LPOSQRL-ddxLdes\caseC}}}}
	\caption{Desired load Position Case C\label{fig:set.caseC2}}
\end{figure}

%***************************************\\
%Bart: Which multiple disciplines? Do you mean Large QR rotations leads to less lifting force which might limit the tracking performance in z-direction\\
%Nam: Ik bedoelde eigenlijk, meerdere objectives. Hoge zijwaartse snelheden, terwijl het hoogte moet tracken. Indirect daarmee ook, testen of het hoogte kan houden terwijl de QR kantelt. Beetje herschreven, beter?
%
%***************************************\\
\clearpage		


\section{Setup}\label{sec:exp.setup}
\paragraph{Model parameters}
The simulations are developed using Matlab$^\text{\textregistered} $ and Simulink$^\text{\textregistered} $ R2013b.
The model parameters to define the system are based on a Parrot$^\text{\textregistered} $ Bebop Drone 1, also used in a research by \cite{Cornelis2014}, see Table \ref{tab:set.par}. The maximum thrust per rotor defines the maximum total thrust and moment. $ m_L $ and $ L $ are chosen arbitrarily.
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|ll|l|}
		\hline
		\textbf{Parameter}&\textbf{Value}&&\textbf{Description}\\
		\hline
		$ m_Q $&0.4& $ kg $&quadrotor Mass\\
		$ l $&0.126& $ m $&Arm length from \a{qr} \a{cm} to rotor\\
		$ I_{xx} $&2.23$ \times 10^{-3}$&$kgm^2 $&quadrotor Inertia about x-axis\\
		$ I_{yy} $&2.99$ \times 10^{-3}$&$kgm^2 $&quadrotor Inertia about y-axis\\
		$ I_{zz} $&4.8$ \times 10^{-3}$&$kgm^2 $&quadrotor Inertia about z-axis\\
    	$ f_{i,max} $&1.96 &$ N $&Maximum thrust per rotor\\
		$ m_L $&0.1 &$ kg $&load Mass\\
		$ L $&0.7 &$ m $& Cable Length\\		
%		$ d $&&&Drag Constant\\
%		$ b $&&&Thrust Constant\\
%		$ c_{\tau_f} $&&& Constant	\\
		\hline		
	\end{tabular}
	\caption{Modeling Parameters}
	\label{tab:set.par}
\end{table}

In order to get a feel for realistic physical limits, these can be based on hardware data, which could be found on the web \footnote{\url{http://blog.parrot.com/2016/01/12/comparison-bebop-2-vs-bebop-drone/}\label{url:set.bebop}}. 
These values are shown in Table \ref{tab:set.par2}, and can be compared with the simulation results, in order to check whether the outcome is in the same order of magnitude of a real physical system.
\begin{table}[h!]
	\centering
	\begin{tabular}{|ll|l|}
		\hline
		\textbf{Value}&&\textbf{Description}\\
		\hline
		13 & $ m/s $&Maximum top speed\\
		2.5& $ m/s $&Maximum vertical speed\\
		30 &$ deg $&Maximum inclination\\
		\hline
	\end{tabular}
	\caption{Hardware Parameters for Bebop Parrot Drone 1}
	\label{tab:set.par2}
\end{table}

%
%***************************************\\
%Bebop 2\\
%500g, 18 m/s, 6 m/s vert, 35 deg
%
%***************************************\\

%***************************************\\
%Bart: Inclination of what? Is this the same as QR Attitude?\\
%Nam: Yes. Just general definition of inclination. Hellingshoek/inclinatie
%
%***************************************\\

% Max lift, 200 g
% Max total force (mQ+mL)*g
% Max f_i = Max total force / 4
% Max torque = 2 * l * max f_i

\paragraph{Command Filtering}
% %ADD Pro Con Command filter
%Easy implementation. Less computational effort.
%Less accurate, because filters high frequency signals.
%CHECK
%Examples from \cite{Farrell2008} and \cite{Djapic2008}. 
A consequence of a backstepping control approach, is that it increases the order of the commanded states. 
The controllers generate control laws that are a function of the commanded signals and their derivatives.
%, which are generated by the controllers in outer loops.
%In the control design, discussed in Chapter \ref{ch:control}, the load attitude controller generates a commanded QR attitude $ R_c $ and its derivative $ \dot{R}_c $. In the same fashion, the load position controller generates a commanded load attitude $ q_c $ and its derivative $ \dot{q}_c $. 
As can be seen in Chapter \ref{ch:control}, the control laws require the values $ R_c, \dot{R}_c, \ddot{R}_c, q_c, \dot{q}_c $ and $ \ddot{q}_c $.
%Calculating the 
Time derivatives of the virtual control variables may be quite complex and the calculation could result in high computational costs.
Instead of analytic differentiation of these terms, which can be tedious, these values can be obtained with the use of a \textit{Command Filter} \cite{Farrell2008,Farrell2005}. 
% %CHECK nodig?
%https://www.researchgate.net/post/Sliding_Mode_controller_Vs_Backstepping_controller
The result of a command filter is that the command signal is being pre-filtered by low pass filters and generates an estimation of the derivatives of the commanded signal. Backstepping command filters are implemented to compute $ \dot{R}_c, \ddot{R}_c,\dot{q}_c, \ddot{q}_c,\dot{x}_{L,d}$ and $\ddot{x}_{L,d} $. 
This approach is explained in more detail in \cite{Borra2012}.
%The transfer function of the original commanded input signal $ X_c^o $ and the filtered output $ X_c $ has the form
%\begin{equation}\label{key}
%\frac{X_c(s)}{X_c^o(s)}=H(s)=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}
%\end{equation}
%Where $ \zeta $ is the damping ratio and $ \omega_n $ the undamped natural frequency. 
%%%CHECK figure niet nodig?
%%See Figure \ref{fig:app.CF}.
%The filter has the following state space representation
%%CHECK waar dit ook alweer vandaan kwam. Reference in Djapic/Farell -> 3e order voor bacterieen ofzo
%\begin{equation}\label{key}
%\begin{aligned}
%\dot{x}_1 &= x_2\\ %dxc
%\dot{x}_2 &= x_3\\ %ddxc
%\dot{x}_3 &= -(2\zeta \omega_{n2}+\omega_{n1})x_3-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_2-(\omega_{n1}\omega_{n2}^2)(x_1-x_c^o)
%\end{aligned}
%\end{equation}
%where $ x_1 = x_c$, $ x_2 = \dot{x}_c$ and $ x_3 = \ddot{x}_c$, such that $ x_c $ is the filtered output. 
The nonlinear state space representation of this filter is given by
\begin{equation}\label{key}
\begin{bmatrix}
x_c\\
\dot{x}_c
\end{bmatrix}
=
\begin{bmatrix}
q_1\\
q_2
\end{bmatrix}
\end{equation}
\begin{equation}\label{key}
\begin{bmatrix}
\dot{q}_1(t)\\
\dot{q}_2(t)
\end{bmatrix}
=
\begin{bmatrix}
q_2\\
2\zeta\omega_n\left( S_R\left\lbrace \frac{\omega_n^2}{2\zeta\omega_n}\left[ S_M(x_c^o)-q_1\right] \right\rbrace-q_2 \right) 
\end{bmatrix}
\end{equation}
where $ S_M $ and $ S_R $ are functions that can limit the magnitude and rate. The implemented command filter is shown in Figure \ref{fig:set.cf}.
\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=.8\textwidth]{./StyleStuff/CFv2.png}}
	\caption{Command Filter\label{fig:set.cf}}
\end{figure}

The chosen values for $ \omega_n $ and $ \zeta $ for the command filters are shown in Table \ref{tab:set.cf}. 
The parameters were determined by trial and error. 
The higher the value for $ \omega_n $, the higher the frequencies that are passed through the filter. 
Whenever the frequency was chosen too high, noisy derivatives are calculated, resulting in a destabilization of the system.
Choosing the values too low resulted in slow responses, and a bad estimation of the derivatives.
The damping ratio $ \zeta $ was chosen high, in order to give a sufficient damping. No limits for the magnitude and rates are implemented, meaning that $ S_M $ and $ S_R $ are omitted.
\begin{table}[h!]
	\centering
\begin{tabular}{|l|lll|}
	\hline
	& \multicolumn{3}{c|}{\textbf{Filter}} \\ \cline{2-4} 
	& $ R  $     & $ q $      & $ x_{L,d} $   \\ \hline
	$ \omega_n $ & 30     & 25     & 25        \\
	$ \zeta  $   & 0.98   & 0.98   & 0.98      \\ \hline
\end{tabular}
	\caption{Command Filter Parameters}
\label{tab:set.cf}
\end{table}

***************************************\\
Bart: Ergens heb ik het gevoel dat dit misschien ook hoort bij je control design chapter en niet pas bij je exprimenten pas. Het is toch onderdeel van je regelaar? Wat vind jij? \\
Nam: Ik ben van mening dat het niet in control design thuis hoort. De controller is ontworpen zonder notie van de command filter en zou zonder moeten kunnen functioneren. 
Het is een keuze om deze te gebruiken om het berkenen van de tijdsafgeleiden van de commanded states te vergemakkelijken. Dus ik vind het tussen de setup horen, net als dat ik bepaalde parameters kies om controllers te tunen. Dat zet ik ook niet al in control design. Mee eens?

***************************************\\

% %CHECK  nodig?
%\begin{figure}[h!]
%	\centering
%	\makebox[\textwidth][c]{\includegraphics[width=.45\textwidth]{./StyleStuff/cf.png}}
%	\caption{Representation of the command filter\label{fig:set.CF}}
%\end{figure}		

%The controllers are functions of these commanded signals and their derivatives. Instead of analytic differentiation of these signals, they are obtained by integration by applying a third order low pass filter to the original signals $ R_c^o $ and $ q_c^o $. 
%The state space implementation of this third order filter is \cite{Djapic2008}
%\begin{align}\label{eq:CF}
%\frac{x_c}{x_c^o}&=\frac{\omega_{n1}}{s+\omega_{n1}}\cdot\frac{\omega_{n2}^2}{s^2+2\zeta\omega_{n2}s+\omega_{n2}^2}\\
%\Rightarrow x_c^{'''}&=-(2\zeta\omega_{n2}+\omega_{n1})x_c^{''}-(2\zeta\omega_{n1}\omega_{n2}+\omega_{n2}^2)x_c^{'}-(\omega_{n1}\omega_{n2} ^2)(x_c-x_c^o)
%\end{align}

\paragraph{Geometric Control}
The chosen controller gains in Equations \ref{eq:con.M}, \ref{eq:con.Fpd} and \ref{eq:con.A} can be found in Table \ref{tab:set.gains}.
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|l|l|}
		\hline
		%63 61 41
		\textbf{Gain}&\textbf{Case A}&\textbf{Case B}&\textbf{Case C}\\
		\hline
		% % % % % %
$	k_R	$	&	0.9	&	0.9	&	0.9	\\
$	k_\Omega	$	&	0.1	&	0.1	&	0.1	\\
$	k_q	$	&	3.9	&	3.9	&	3.9	\\
$	k_\omega	$	&	2	&	2	&	2	\\
$	k_x	$	&	6	&	6	&	6	\\
$	k_v	$	&	2.75	&	2.75	&	2.75	\\
		% % % % % %	
		\hline
	\end{tabular}
	\caption{Controller Gains nonlinear geometric controller}
	\label{tab:set.gains}
\end{table}

\paragraph{LQR control}
%ADD why LQR, what is good for / known for
% tuning / easy tuning / 
\acf{lqr} control uses an algorithm to obtain a state-feedback controller, minimizing a cost function depending on the states and weight factors. 
An \a{lqr} design is shown in Figure \ref{fig:set.lqr}
\begin{figure}[h!]
	\centering
	\makebox[\textwidth][c]{\includegraphics[trim={2cm 0 2cm 14cm},clip,width=.65\textwidth]{./StyleStuff/lqr.png}}
	\caption{LQR control design\label{fig:set.lqr}}
\end{figure}

\a{lqr} control is based on a small angle assumption. 
Therefore, following a traditional modeling method, the rotation matrix is represented with a local coordinate system, 
%Therefore, a traditional modeling method may represent the rotation matrix with a local coordinate system, 
for example with an Euler Angle parameterization. 
A continuous time linearized model of the system used in this controller is represented in the following form 
\begin{align}\label{eq:ss}
\mathbf{\dot{x} }&=A\mathbf{x}+Bu\\
y&=C\mathbf{x}+Du
\end{align}
where $ \mathbf{x} $ is the state vector and $ u $ is the input vector, defined as follows
\begin{align}\label{eq:state}
%	\textbf{x}&=\begin{bmatrix}
%		\textbf{q}\\
%		\mathbf{\dot{q}}
%	\end{bmatrix}\\
%	\mathbf{q}&=\begin{bmatrix}
%		x&y&z&\phi&\theta&\psi&\phi_L&\theta_L
%	\end{bmatrix}^T\\
%	\mathbf{\dot{q}}&=\begin{bmatrix}
%		\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\phi}_L&\dot{\theta}_L
%	\end{bmatrix}^T\\
\mathbf{x}&=\begin{bmatrix}
x&y&z&\phi&\theta&\psi&\phi_L&\theta_L&\dot{x}&\dot{y}&\dot{z}&\dot{\phi}&\dot{\theta}&\dot{\psi}&\dot{\phi}_L&\dot{\theta}_L
\end{bmatrix}^T\\
u&=\begin{bmatrix}
f&M_\phi&M_\theta&M_\psi
\end{bmatrix}^T
\end{align}

Using \texttt{Matlab} command \texttt{lqr(A,B,Q,R)}, an optimal gain matrix $ K $ is calculated, such that the state-feedback law $ u=-K(\mathbf{x-x_{ref}}) $ \cite{Reyes-Valeria2013} minimizes the quadratic cost function. Where the cost function is defined as 
\begin{equation}\label{key}
J(u)=\int_{0}^{\infty}(\mathbf{x}^TQ\mathbf{x}+u^TRu)dt
\end{equation}
%where $ Q $ and $ R $ denote weight matrices that penalize the states and inputs in the cost function. 
The weight matrices $ Q $ and $ R $ define the effects of the states and inputs in the cost function, and the gain matrix $K $ can be calculated. 
The derivation of the state space matrices $ A, B, C, D $, the weight matrices $ Q,R $ and the calculated gain matrix $ K $ can be found in Section \ref{app:lqr}. 

\newpage
\section{Results}\label{sec:exp.results}
%ADD inputs f M
%ADD QR attitude
In this section the results of the experiments are discussed, for each case separately. 
%Figures \ref{fig:set.caseAres}, \ref{fig:set.caseBres} and \ref{fig:set.caseCres} show 
The load tracking performance for the nonlinear geometric controller is discussed by analyzing the desired and actual load trajectories,   
%The desired load trajectories $ x_{L,d} $ and actual load trajectories $ x_L $ are shown, 
together with the corresponding load position and velocity errors.\\
%$ e_x $ and velocity error $ e_v $.\\ 
The stability of the closed-loop system is investigated by observing whether the controller is able to bring the system to a stationary final state.
The error dynamics are analyzed through the error functions, as described in Chapter \ref{ch:control}. 
%If the required initial conditions are satisfied
%Figures \ref{fig:set.caseAres2}, \ref{fig:set.caseBres2} and \ref{fig:set.caseCres2} show 
The configuration errors $ \Psi_R, \Psi_q $
and the corresponding tracking errors of the \a{qr} attitude $ e_R, e_\Omega $, load attitude $ e_q, e_{\dot{q}} $ are presented.\\
%, which can be analyzed to check the system's stability.\\
Finally, the load position tracking results of the nonlinear geometric controller and a \a{lqr} controller are compared.
%Figures \ref{fig:set.caseAres3}, \ref{fig:set.caseBres3} and \ref{fig:set.caseCres3} show the differences in controller performance.


***************************************\\
Bart: Suggestie: Misschien een section analysis zou kunnen hepen.. Daarin kun je ook vermelden dat je de percentage error bekijkt etc. 
Ik lees in deze alinea bijv. dat de NGC en LQR worden vergeleken: op dit punt denk ik dan, ja maar wat wa t wordt er dan precies vergeleken en wordt dat genoemd in de voorgaande sections. Een analysis section zou dat dan kunnen beschrijven.\\
Nam: Daar had ik Section \ref{sec:exp.proc} voor in gedachte. Eerste alinea aangepast. Voldoende?

***************************************\\

\subsection*{Case A}
In this case, the desired trajectory was shaped like a smooth step-like function to investigate the response of the system to a sudden input.
The desired and actual load position, velocity and acceleration are shown in Figure \ref{fig:AxL} and \ref{fig:AdxL}. 
The corresponding load position and velocity error are shown in Figure \ref{fig:AexL}.

\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-xL\caseA}}\label{fig:AxL}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-dxLd-ddxLd\caseA}}\label{fig:AdxL}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-exL\caseA}}\label{fig:AexL}}}
	\caption{Load Position Tracking \a{ngc} Case A \label{fig:set.caseAres}}
\end{figure}

%\begin{figure}[h!]
%	\centering
%	\makebox[.49\textwidth][c]{{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-dxLd-ddxLd\caseA}}\label{fig:AdxL}}}	
%	\caption{Load Velocity and Acceleration Case A\label{fig:}}
%\end{figure}

Since this function is different from a normal step function, it might be less meaningful to say something about the rise time. 
Normally one checks the time it takes to reach $ 90\% $ of the step height. 
In this case, the step is a smooth function, meaning that the system is not forced to the step height instantly, but in a smooth manner. 
However, it can be seen in Figure \ref{fig:AexLdlqr} that the required time such that $ 90 \% $ of the desired value is reached for the first time is 
%CHECK
$ 0.61 s $.
It can be observed that the system responds with approximately $ 15 \% $ overshoot in the y-direction, and loses height during this maneuver.
This was to be expected due to large \a{qr} rotations. The error remains within a $ 5 \% $ error bound after 
%CHECK
$ 1.26 s $, 
to eventually reach a steady-state at the step size of $ 0.25 m $. 
%CHECK 
%to increase at a high rate, causing commanded signals to change at high rates. Due to limited bandwidth in the commanded filters, this could cause 


Figure \ref{fig:AeR} and \ref{fig:Aeq} show the tracking errors of the \a{qr} attitude and load attitude, respectively. 
The error in \a{qr} attitude and angular velocity are large at the moments the slope starts and ends, indicating the required sudden \a{qr} rotation and high angular velocity are larger than the system can manage.
%to respond to the sudden input. 
Nevertheless, the figures indicate that the errors in both \a{qr} and load attitude are driven to zero relatively fast.
Furthermore, Figure \ref{fig:APsiR} and \ref{fig:APsiq} show that the tracking error functions of the \a{qr} and load, respectively, are also driven to zero.
From this can be concluded that $(e_x,e_v,e_q,e_{\dot{q}},e_R,e_\Omega)=(0,0,0,0,0,0) $ is exponentially stable. 
%The figures show that $ (e_x,e_v)=(0,0) $ is exponentially attractive. 
% \\
%From this can be observed that there exist constants $ \alpha,\beta>0 $ for both $ \Psi_R $ and $ \Psi_q $, such it holds that $ \leq min\left\lbrace 2,\alpha e^{-\beta t}\right\rbrace $
%Observations: there exist constants $ \alpha_q,\beta_q>0 $ such that
%\begin{equation}\label{key}
%\Psi_q(q(t),q_d(t)) \leq min\left\lbrace 2,\alpha e^{-\beta t}\right\rbrace 
%\end{equation}
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eR\caseA}}\label{fig:AeR}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eq\caseA}}\label{fig:Aeq}}}	
	\caption{Geometric Error functions \a{ngc} Case A \label{}}
\end{figure}	
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-PsiR\caseA}}\label{fig:APsiR}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-Psiq\caseA}}\label{fig:APsiq}}}
	\caption{Geometric Tracking Error functions \a{ngc} Case A \label{}}
\end{figure}	

***************************************\\
Bart: Srry dat ik hem even kwijt ben (t is al laat :p), maar je wil toch QR load position tracken. Wat is hier dan de error in QR attitude en load attitude? Deze willen we toh niet tracken?\\
Nam: Klopt, deels. Maar om het geheel stabiel te houden moeten deze waardes wel naar nul gebracht worden. Dus, dit concludeert dat het systeem closed-loop stabiel is. Onderbelicht of nu wel duidelijk?

***************************************\\

For both control approaches, Figure \ref{fig:AxLlqr} shows the load position along the desired load position $ x_{L,d} $ and Figure \ref{fig:AexLlqr} shows the corresponding load position error. From this can be observed that the \a{lqr} controller has a slower response, larger overshoot and higher settling time. Due to the aggressive maneuver by the \a{ngc} control, the system has a steady-state offset in height. It was found that this can be resolved by tuning the controller with smaller gains or decreasing the cut-off frequency of the low pass filters, which both result in smoother, but slower responses. \\
Figure \ref{fig:AexLdlqr} shows the absolute position error over the desired load position in percentages. It can be observed that the \a{lqr} controller requires more time to stabilize the load angle, whereas the \a{ngc} controller is capable of damping the oscillation in a smooth manner.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][ \label{fig:AxLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-xL\caseA}}}}
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:AexLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL\caseA}}}}	
	\makebox[.49\textwidth][c]{\subfloat[][load Position Error Percentage\label{fig:AexLdlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL_xLd\caseA}}}}		
	\caption{Controller Comparison Case A. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:set.caseAres3}}	
\end{figure}

***************************************\\
Bart: Is er niet net als bij simpel PID een integrator die de ss fout eruit kan halen zonder je response verder te verslechteren?\\
Nam: Heb ik wel ergens over gelezen, maar dat vereist een heel andere controller erbij. Om de een of andere reden heb ik er alleen bij de step response last van. Bovendien is het maar 1.5 mm steady state error. Is dat uberhaupt significant?

***************************************\\


***************************************\\
Bart: Waarom ziet jouw controller niet die kleine error en lost hij die uiteindelijk op? hij wil de position error toch naar nul hebben. Dus je hebt een kleine error -> je control output is iets verhoogt -> je actuators zijn ietsje actief -> dus langzaam verwdwijnt de error. Er is toch geen stick slip aar jouw systeem op hangt als bij een pid zonder I?\\
Nam: Er is zeker geen stick slip in mijn model. Dan zou ik de rotor dynamics ook nog eens moeten modeleren. Ik heb geprobeerd de gain te verhogen op de positie controller, maar het systeem reageert dan heel heftig op voorgaande error, maar niet significant meer op de steady state error. Ik heb echt geen flauw benul hoe het kan.

***************************************\\

Figure \ref{fig:AQRang} shows the \a{qr} attitude with respect to \IF, and a huge difference in the \a{qr} rotations during the maneuver can be observed, note the difference in scale. It is obvious that the \a{ngc} controller is capable of handling more aggressive maneuvers. Figure \ref{fig:ALang} shows the load angle with respect to \IF. The \a{ngc} controller allows larger angles of the load attitude, while stabilization is reached relatively fast. The \a{lqr} controller tries to minimize the swing along the entire trajectory, not allowing large angles of the load attitude.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:AQRang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-QRang\caseA}}}}
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:ALang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-Lang\caseA}}}}	
	\caption{Controller Comparison Case A. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:set.caseAres4}}	
\end{figure}
\clearpage

\subsection*{Case B}
In this case, the desired trajectory was designed to investigate the response of the system to increasing distance and velocities between the ends of a swinging motion.
The desired and actual load position, velocity and acceleration are shown in Figure \ref{fig:BxL} and \ref{fig:BdxL}. 
The corresponding load position and velocity error are shown in Figure \ref{fig:BexL}.
Despite the fact that case B requires higher velocities than in case A, the trajectory gradually increases the distance of the load position, which requires less sudden aggressive commanded rotations. It can be seen that acceleration in case B is a lot smoother than in case A, which explains why also both the velocity and position are smooth enough for the system to track.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-xL\caseB}}\label{fig:BxL}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-dxLd-ddxLd\caseB}}\label{fig:BdxL}}}		
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-exL\caseB}}\label{fig:BexL}}}	
	\caption{Load Position Tracking nonlinear geometric control Case B \label{fig:set.caseBres}}
\end{figure}	
%\begin{figure}[h!]
%	\centering
%	\makebox[.49\textwidth][c]{{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-dxLd-ddxLd\caseB}}\label{fig:BdxL}}}	
%	\caption{Load Velocity and Acceleration Case B\label{fig:}}
%\end{figure}

Figure \ref{fig:BeR} and \ref{fig:Beq} show the tracking errors of the \a{qr} attitude and load attitude, respectively. The error in \a{qr} attitude and angular velocity is much smaller compared to the results in case A, which indicates that the system is fast enough to respond to the required \a{qr} rotations and velocities.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eR\caseB}}\label{fig:BeR}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eq\caseB}}\label{fig:Beq}}}	
	\caption{Geometric Error functions \a{ngc} Case B \label{}}
\end{figure}	

Both \a{qr} and load attitude errors stay bounded during the trajectory and are driven to zero. 
Furthermore, Figure \ref{fig:BPsiR} and \ref{fig:BPsiq} show a gradual increase and decrease in error, similar to the profile of the desired velocity. 
All error functions are driven to zero, and it can also be concluded for this case that $(e_x,e_v,e_q,e_{\dot{q}},e_R,e_\Omega)=(0,0,0,0,0,0) $ is exponentially stable. 
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-PsiR\caseB}}\label{fig:BPsiR}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-Psiq\caseB}}\label{fig:BPsiq}}}
	\caption{Geometric Tracking Error functions \a{ngc} Case B \label{}}
\end{figure}	

Figure \ref{fig:BxLlqr} shows the actual and desired load position for both control approaches. The shape of the actual load position appears to be quite similar. However, taking a look at Figure \ref{fig:BexLlqr} shows the load position error for both control approaches. It is clear that the \a{lqr} controller fails to track the load position, since errors can be seen to reach values up to $ 1.1 m $. \\
The profile of the \a{qr} rotation angles are surprisingly alike, as can be seen in Figure \ref{fig:BQRang}. However, it can be seen in Figure \ref{fig:BLang} that the load swings significantly more when controlled by the \a{lqr}. This shows that the \a{lqr} controller struggles with both keeping up with the position, while minimizing the load swing. The shape of the trajectory is nearly correct, but the controller is too slow to correct for the \a{qr} position and not capable of correcting the load position error. The load continues its natural swing, which increases the error even more.  
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:BxLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-xL\caseB}}}}
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:BexLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL\caseB}}}}	
%		\makebox[.49\textwidth][c]{\subfloat[][load Position Error Percentage\label{fig:BexLdlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL_xLd\caseB}}}}	
	\caption{Controller Comparison Case B. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:}}
\end{figure}\\	
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:BQRang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-QRang\caseB}}}}
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:BLang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-Lang\caseB}}}}
	%	\makebox[.49\textwidth][c]{\subfloat[][load Position Error Percentage\label{fig:BexLdlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL_xLd\caseB}}}}	
	\caption{Controller Comparison Case B. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:}}
\end{figure}	
\clearpage

\newpage
\subsection*{Case C}
The last case is designed to investigate the response on a load trajectory in three directions, each direction with a different shape. 
The desired and actual load position, velocity and acceleration are shown in Figure \ref{fig:CxL} and \ref{fig:CdxL}. 
The corresponding load position and velocity error are shown in Figure \ref{fig:CexL}.

%While tracking the required \a{qr} attitude, which tilts the \a{qr} to reach the desired velocities in the right direction, it can be seen that the system has difficulties to also maintain the desired height, which can be explained by the fact that the total force will not point upwards if the \a{qr} is tilted. Despite the fact that the \a{qr} is  moving from side to side, the upward force is still controlled to track the desired height. 
\begin{figure}[h!]
	\centering
	\makebox[.495\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-xL\caseC}}\label{fig:CxL}}}	
	\makebox[.495\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-dxL\caseC}}\label{fig:CdxL}}}	
	\makebox[.495\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-exL\caseC}}\label{fig:CexL}}}	
	\caption{Load Position Tracking nonlinear geometric control Case C \label{fig:set.caseCres}}
\end{figure}	
%
%Figure \ref{fig:CeR} and \ref{fig:Ceq} show the tracking errors of the \a{qr} attitude and load attitude, respectively. \\
%Observations: $(e_x,e_v,e_q,e_{\dot{q}},e_R,e_\Omega)=(0,0,0,0,0,0) $ is exponentially stable.

From Figures  \ref{fig:CexL}, \ref{fig:CeR}, \ref{fig:Ceq}, \ref{fig:CPsiR} and \ref{fig:CPsiq} can be 
%All error functions are driven to zero, and it can also be 
concluded for this case it also holds that $(e_x,e_v,e_q,e_{\dot{q}},e_R,e_\Omega)=(0,0,0,0,0,0) $ is exponentially stable.
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eR\caseC}}\label{fig:CeR}}}	
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-eq\caseC}}\label{fig:Ceq}}}	
	\caption{Geometric Error functions \a{ngc} Case C \label{}}
\end{figure}	
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-PsiR\caseC}}\label{fig:CPsiR}}}
	\makebox[.49\textwidth][c]{\subfloat[][]{\includegraphics[width=.49\textwidth]{\dir{LPOSQRL-Psiq\caseC}}\label{fig:CPsiq}}}
	\caption{Geometric Tracking Error functions \a{ngc} Case C \label{}}
\end{figure}	

Figure \ref{fig:CexLlqr} shows the load position error for both control approaches.

Figure \ref{fig:CxLlqr} shows the actual and desired load position for both control approaches. As in case B, the shape of the actual load position is quite similar. However, Figure \ref{fig:CexLlqr} shows the load position error for both control approaches.
It is not surprising that the \a{lqr} controller fails again to track the load position, for the trajectory is more complex than the other cases. 
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][  \label{fig:CxLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-xL\caseC}}}}
	\makebox[.49\textwidth][c]{\subfloat[][  \label{fig:CexLlqr}]{\includegraphics[width=.49\textwidth]{\dir{LQR-exL\caseC}}}}
	\caption{Controller Comparison Case C. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:set.}}
\end{figure}	

Figure \ref{fig:CQRang} shows the \a{qr} attitude with respect to \IF. It can be observed that the \a{qr} angles are shaped very differently. 
The \a{ngc} \a{qr} attitude controller is able to calculate the required rotation along the trajectory, based on the error information. 
%The commands that are sent by the \a{lqr} results in a smooth response, but
%sends smooth commands to the system, resulting in a 
% in a smooth
In Figure \ref{fig:CLang} the load angle with respect to \BF is shown. The load angle by \a{ngc} has a peculiar shape, for it is not a smooth sine-wave like shape. From the peaks in the tops can be concluded that the load angle is actively steered by the rotations shown earlier in Figure \ref{fig:CQRang}. 
\begin{figure}[h!]
	\centering
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:CQRang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-QRang\caseC}}}}
	\makebox[.49\textwidth][c]{\subfloat[][\label{fig:CLang}]{\includegraphics[width=.49\textwidth]{\dir{LQR-Lang\caseC}}}}
	\caption{Controller Comparison Case C. Solid: \a{ngc}, Dash-dot: \a{lqr}\label{fig:set.}}
\end{figure}	
\clearpage

\newpage
\section{Summary}\label{set:exp.con}
%CHECK 
%What can we learn and conclude from different performance comparisons
In this chapter, the nonlinear geometric controller was tested for its ability to track various load trajectories. 
It w
Experimental procedures described by defining 

The control design is capable of stabilizing the system and enables tracking of a load trajectory. 


of tracking various
load position tracking

The \a{lqr} control commands small rotations in order to succeed in both position tracking of the \a{qr} and minimization of the load swing.
The \a{ngc} control commands large \a{qr} rotations in order to create a large influence on the load attitude dynamics, see Equation \ref{eq:mod.loadatt}. 

High gains in the \a{qr} attitude controller forces the \a{qr} to large and fast rotations. 



Near the equilibrium configuration, the \a{lqr} controller is able to reduce the swing fast and accurate, as can be seen in the results of case A. 
However, the shortcomings of the \a{lqr} controller become evident when it is commanded to track fast trajectories. Following these trajectories continuously requires fast changing movements, far away from the equilibrium configuration. The controller is not able to cope with the fast changing dynamics, resulting in overshoots and slow responses, lagging behind the desired trajectory.

The controllers are functions of the computed tracking references $ q_c, R_c $ and their derivatives. These terms are approximated by a command filter, which means that the accuracy decreases because high frequency terms are filtered.

%CHECK
%It can be expected that the nonlinear geometric control allows large \a{qr} angles, whereas the \a{lqr} will possible fail to deviate far from the equilibrium point. 


%ADD conclusie 
% over parameter keuze in controllers. Arbitrair, maar wellicht later wel van belang



